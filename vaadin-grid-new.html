<link rel="import" href="vaadin-scroller.html">
<link rel="import" href="vaadin-grid-dynamic-columns-behavior.html">
<link rel="import" href="vaadin-grid-data-provider-behavior.html">
<link rel="import" href="vaadin-grid-table-scroll-behavior.html">

<link rel="import" href="vaadin-grid-styles.html">

<dom-module id="vaadin-grid">
  <template>
    <style include="vaadin-grid-styles"></style>

    <div id="scroller">
      <table id="table">
        <thead id="header"></thead>
        <tbody id="items"></tbody>
        <tfoot id="footer"></tfoot>
      </table>
    </div>

    <!-- The template needs at least one slot or else shady doesn't distribute -->
    <slot name="nodristribute"></slot>

  </template>
</dom-module>

<script>
  class VaadinGrid extends Polymer.mixinBehaviors(
    [
      vaadin.elements.grid.DynamicColumnsBehavior,
      vaadin.elements.grid.DataProviderBehavior,
      vaadin.elements.grid.TableScrollBehavior
    ],
    VaadinScroller) {

    static get is() {
      return 'vaadin-grid';
    }

    static get observers() {
      return [
        '_columnTreeChanged(_columnTree, _columnTree.*)',
      ]
    }

    _createScrollerRow() {
      const row = document.createElement('tr')
      this._updateRow(row, this._columnTree[this._columnTree.length - 1]);
      return row;
    }

    _getRowTarget() {
      return this.$.items;
    }

    _updateRow(row, columns, templateName) {
      templateName = templateName || 'template';
      // Create the row cells programmatically to avoid a <template> tag
      const cellsFragment = document.createDocumentFragment();
      const contentsFragment = document.createDocumentFragment();

      columns.forEach((column, index) => {
        // TODO: USE CACHE FOR THESE (RE-USE FREE ID (ALREADY HAS A CONTENT IN DOM, JUST USE THE ID ON SLOT))
        // {
          const contentId = vaadin.elements.grid._contentIndex = vaadin.elements.grid._contentIndex + 1 || 0;
          const id = 'vaadin-grid-cell-content-' + contentId;
          const inst = column[templateName].templatizer.createInstance();

          const cellContent = document.createElement('vaadin-grid-cell-content');
          cellContent.setAttribute('slot' , id);
          cellContent.appendChild(inst.root);
          contentsFragment.appendChild(cellContent);
        // }

        const cell = document.createElement('td');
        column.push('_cells', cell); // TODO: This is really heavy, batch/debounce it


        cell.classList.add('vaadin-grid-cell');

        cell._instance = inst;
        const slot = document.createElement('slot');
        slot.setAttribute('name', id);
        cell.appendChild(slot);
        cellsFragment.appendChild(cell)
      });

      row.innerHTML = '';
      row.appendChild(cellsFragment);

      // Might be empty if only cache was used
      this.appendChild(contentsFragment);

      this._frozenCellsChanged();
    }

    _updateScrollerItem(row, index) {
      const columns = this._columnTree[this._columnTree.length - 1];
      // Polymer.Templatizer.modelForElement(row)
      columns.forEach((column, columnIndex) => {
        const cell = row.children[columnIndex];
        const slot = cell.firstElementChild;
        const inst = cell._instance;

        inst.index = index;
      });
      this._getItem(index, row);
    }

    _columnTreeChanged(columnTree, splices) {
      Array.from(this.$.items.children).forEach(this._updateRow.bind(this, columnTree[columnTree.length - 1]));

      while (this.$.header.children.length < columnTree.length) {
        this.$.header.appendChild(document.createElement('tr'));
      }
      while (this.$.header.children.length > columnTree.length) {
        this.$.header.removeChild(this.$.header.firstElementChild);
      }

      Array.from(this.$.header.children).forEach((headerRow, index) => {
        this._updateRow(headerRow, columnTree[index], 'headerTemplate');
      });



    }

    _updateItem(row, item) {
      // row.style.minHeight = item ? '' : this.$.scroller._physicalAverage + 'px';
      Array.from(row.children).forEach((cell) => {
        cell._instance.item = item;
      });
      // row.selected = this._isSelected(item);
      // row.expanded = this._isExpanded(item);
      // row.active = item !== null && item == this.activeItem;
      // row.focused = row.index === this.$.items._focusedRowIndex;
    }
  }

  customElements.define(VaadinGrid.is, VaadinGrid);
</script>
