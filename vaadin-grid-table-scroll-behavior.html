<link rel="import" href="../iron-scroll-target-behavior/iron-scroll-target-behavior.html">

<dom-module id="vaadin-grid-table-table-scroll-styles">
  <template>
    <style>
      #table {
        position: relative;
        overflow: auto;
        -webkit-overflow-scrolling: touch;
        z-index: -2;
      }

      vaadin-grid-table[ios] #table {
        transform: none;
      }

      vaadin-grid-table[fixed-sections] #table {
        transform: none;
      }
    </style>
  </template>
</dom-module>

<dom-module id="vaadin-grid-table-scroll-styles">
  <template>
    <style>
      vaadin-grid-table {
        transform: translateZ(0);
      }

      vaadin-grid-table-header {
        position: absolute;
        top: 0;
        width: 100%;
      }

      vaadin-grid-table-footer {
        position: absolute;
        bottom: 0;
        width: 100%;
      }

      vaadin-grid-table-body {
        z-index: -1;
      }

      vaadin-grid-table[fixed-sections] {
        /* Any value other than ‘none’ for the transform results in the creation of both a stacking context and
        a containing block. The object acts as a containing block for fixed positioned descendants. */
        transform: translateZ(0);
        overflow: hidden;
      }

      vaadin-grid-table[fixed-sections] vaadin-grid-table-header,
      vaadin-grid-table[fixed-sections] vaadin-grid-table-footer {
        position: fixed;
      }

      vaadin-grid-table[fixed-sections] vaadin-grid-table-body#items {
        position: fixed;
        width: 100%;
        will-change: transform;
      }
    </style>
  </template>
</dom-module>

<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  /**
   * @polymerBehavior vaadin.elements.grid.TableScrollBehaviorImpl
   */
  vaadin.elements.grid.TableScrollBehaviorImpl = {

    properties: {

      _vidxOffset: {
        type: Number,
        value: 0
      },

      ios: {
        type: Boolean,
        value: navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/),
        reflectToAttribute: true
      },

      fixedSections: {
        type: Boolean,
        reflectToAttribute: true,
        computed: '_hasFixedSections(scrollbarWidth)'
      },

      // Cached array of frozen cells
      _frozenCells: {
        type: Array,
        value: function() {
          return [];
        }
      },

      scrolling: {
        type: Boolean,
        reflectToAttribute: true
      }
    },

    ready: function() {
      this.scrollTarget = this.$.table;
    },

    attached: function() {
      this.listen(this.scrollTarget, 'wheel', '_onWheel');
    },

    detached: function() {
      this.unlisten(this.scrollTarget, 'wheel', '_onWheel');
    },


    _hasFixedSections: function(scrollbarWidth) {
      return navigator.userAgent.match(/Edge/) && scrollbarWidth === 0;
    },

    _onWheel: function(e) {
      if (e.ctrlKey || this._hasScrolledAncestor(e.target, e.deltaX, e.deltaY)) {
        return;
      }

      var table = this.$.table;
      var momentum = Math.abs(e.deltaX) + Math.abs(e.deltaY);

      if (this._canScroll(table, e.deltaX, e.deltaY)) {
        e.preventDefault();
        table.scrollTop += e.deltaY;
        table.scrollLeft += e.deltaX;
        this._scrollHandler();
        this._hasResidualMomentum = true;

        this._ignoreNewWheel = this.debounce('ignore-new-wheel', function() {
          this._ignoreNewWheel = null;
        }, 500);
      } else if (this._hasResidualMomentum && momentum <= this._previousMomentum || this._ignoreNewWheel) {
        e.preventDefault();
      } else if (momentum > this._previousMomentum) {
        this._hasResidualMomentum = false;
      }
      this._previousMomentum = momentum;
    },

    /**
     * Determines if the element has an ancestor prior to this
     * cell content that handles the scroll delta
     */
    _hasScrolledAncestor: function(el, deltaX, deltaY) {
      if (this._canScroll(el, deltaX, deltaY)) {
        return true;
      } else if (el.localName !== 'vaadin-grid-cell-content' && el !== this && el.parentElement) {
        return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);
      }
    },

    /**
     * Determines if the the given scroll deltas can be applied to the element
     * (fully or partially)
     */
    _canScroll: function(el, deltaX, deltaY) {
      return (deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight) ||
      (deltaY < 0 && el.scrollTop > 0) ||
      (deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth) ||
      (deltaX < 0 && el.scrollLeft > 0);
    },

    /**
     * Update the models, the position of the
     * items in the viewport and recycle tiles as needed.
     */
    _afterScroll: function(e) {
      // this._adjustVirtualIndexOffset(delta);

      this._translateStationaryElements();

      if (!this.hasAttribute('reordering')) {
        this.scrolling = true;
      }
      this.debounce('vaadin-grid-scrolling', function() {
        this.scrolling = false;
        this._reorderRows();
      }, 100);
    },

    // correct order needed for preserving correct tab order between cell contents.
    _reorderRows: function() {
      var body = this.root;
      var items = body.querySelectorAll('vaadin-grid-table-row');
      if (!items.length) {
        return;
      }

      var _adjustedVirtualStart = this._virtualStart + this._vidxOffset;

      // DOM index of the element with the lowest index
      var physicalIndexOfFirst = items.length - (items[0].index - _adjustedVirtualStart);

      // Reorder the DOM elements
      if (physicalIndexOfFirst < items.length / 2) {
        // Append all the preceding elements after the last element
        for (var i = 0; i < physicalIndexOfFirst; i++) {
          body.appendChild(items[i]);
        }
      } else {
        // Prepend all the trailing elements before the first element
        for (var j = physicalIndexOfFirst; j < items.length; j++) {
          body.insertBefore(items[j], items[0]);
        }
      }
    },

    _frozenCellsChanged: function() {
      this.debounce('cache-elements', function() {
        Polymer.dom(this.root).querySelectorAll('.vaadin-grid-cell').forEach(function(cell) {
          cell.style.transform = '';
        });
        this._frozenCells = Array.prototype.slice.call(Polymer.dom(this.root).querySelectorAll('[frozen]'));
        this._translateStationaryElements();
      });
      this._updateLastFrozen();
    },

    _updateLastFrozen: function() {
      if (!this._columnTree) {
        return;
      }

      var columnsRow = this._columnTree[this._columnTree.length - 1].slice(0);
      columnsRow.sort(function(a, b) {
        return a._order - b._order;
      });
      var lastFrozen = columnsRow.reduce(function(prev, col, index) {
        col._lastFrozen = false;
        return col.frozen && !col.hidden ? index : prev;
      }, undefined);
      if (lastFrozen !== undefined) {
        columnsRow[lastFrozen]._lastFrozen = true;
      }
    },

    _translateStationaryElements: function() {
      if (this.fixedSections) {
        this.$.items.style.transform =
        this._getTranslate(-this._scrollLeft || 0, -this._scrollTop || 0);

        this.$.footer.style.transform = this.$.header.style.transform =
        this._getTranslate(-this._scrollLeft || 0, 0);
      } else {
        this.$.footer.style.transform = this.$.header.style.transform = this._getTranslate(0, this._scrollTop);
      }

      var frozenCellTransform = this._getTranslate(this._scrollLeft, 0);
      for (var i = 0; i < this._frozenCells.length; i++) {
        this._frozenCells[i].style.transform = frozenCellTransform;
      }
    },

    _getTranslate: function(x, y) {
      return 'translate(' + x + 'px,' + y + 'px)';
    }

  };

  /**
   * @polymerBehavior vaadin.elements.grid.TableScrollBehavior
   */
  vaadin.elements.grid.TableScrollBehavior = [
    // Polymer.IronScrollTargetBehavior,
    vaadin.elements.grid.TableScrollBehaviorImpl
  ];

</script>
